import * as tf from "@tensorflow/tfjs-node";
import fs from "fs";
import path from "path";
import { fileURLToPath } from 'url';


const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
async function checkModel() {
  console.log("🔍 Checking TensorFlow.js Node setup...");
  console.log("📦 TensorFlow.js version:", tf.version);
  console.log("🔧 Node.js version:", process.version);
  
  const modelPath = "model/model.json";

  console.log("📁 Model path:", modelPath);
  
  // Check if model files exist
  if (!fs.existsSync(modelPath)) {
    console.error("❌ Model file not found at:", modelPath);
    console.log("📝 Make sure you have the following files:");
    console.log("   - model/model.json");
    console.log("   - model/model_weights.bin (or similar weight files)");
    return false;
  }
  
  console.log("✅ Model file found");
  
  // Check model.json content
  try {
    const modelConfig = JSON.parse(fs.readFileSync(modelPath, 'utf8'));
    console.log("📋 Model config preview:");
    console.log("   - Format:", modelConfig.format || "unknown");
    console.log("   - Generated by:", modelConfig.generatedBy || "unknown");
    console.log("   - Weights manifest entries:", modelConfig.weightsManifest?.length || 0);
    
    
    // Check weight files
    if (modelConfig.weightsManifest) {
      for (const weightGroup of modelConfig.weightsManifest) {
        for (const path of weightGroup.paths) {
          const weightPath = "model/model.json";
          if (fs.existsSync(weightPath)) {
            const stats = fs.statSync(weightPath);
            console.log(`   ✅ ${path} (${(stats.size / 1024 / 1024).toFixed(2)} MB)`);
          } else {
            console.log(`   ❌ ${path} (missing)`);
          }
        }
      }
    }
    
  } catch (err) {
    console.error("❌ Error reading model config:", err.message);
    return false;
  }
  
  // Try to load the model
  console.log("\n🔄 Attempting to load model...");
  try {
    const model = await tf.loadGraphModel(`file://${modelPath}`);
    console.log("✅ Model loaded successfully!");
    
    console.log("📊 Model details:");
    console.log("   - Inputs:", model.inputs.length);
    model.inputs.forEach((input, i) => {
      console.log(`     Input ${i}: shape ${JSON.stringify(input.shape)}, dtype: ${input.dtype}`);
    });
    
    console.log("   - Outputs:", model.outputs.length);
    model.outputs.forEach((output, i) => {
      console.log(`     Output ${i}: shape ${JSON.stringify(output.shape)}, dtype: ${output.dtype}`);
    });
    
    // Test prediction dengan dummy data
    console.log("\n🧪 Testing prediction with dummy data...");
    const dummyInput = tf.randomNormal([1, 224, 224, 3]);
    const prediction = model.predict(dummyInput);
    
    if (prediction instanceof tf.Tensor) {
      console.log("✅ Prediction successful!");
      console.log("   - Output shape:", prediction.shape);
      const data = await prediction.data();
      console.log("   - Output size:", data.length);
      console.log("   - Sample values:", Array.from(data.slice(0, 5)).map(x => x.toFixed(4)));
      
      prediction.dispose();
    } else {
      console.log("⚠️ Unexpected prediction output type:", typeof prediction);
    }
    
    dummyInput.dispose();
    model.dispose();
    
    console.log("\n🎉 Model check completed successfully!");
    return true;
    
  } catch (err) {
    console.error("❌ Error loading model:", err.message);
    console.error("Stack trace:", err.stack);
    return false;
  }
}

// Run the check
checkModel().then((success) => {
  if (success) {
    console.log("\n✨ Your model is ready to use!");
    process.exit(0);
  } else {
    console.log("\n🚨 Model check failed. Please fix the issues above.");
    process.exit(1);
  }
}).catch((err) => {
  console.error("🚨 Unexpected error:", err);
  process.exit(1);
});